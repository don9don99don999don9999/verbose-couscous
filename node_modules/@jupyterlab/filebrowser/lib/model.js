"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var docmanager_1 = require("@jupyterlab/docmanager");
var algorithm_1 = require("@phosphor/algorithm");
var coreutils_2 = require("@phosphor/coreutils");
var signaling_1 = require("@phosphor/signaling");
/**
 * The duration of auto-refresh in ms.
 */
var REFRESH_DURATION = 10000;
/**
 * The enforced time between refreshes in ms.
 */
var MIN_REFRESH = 1000;
/**
 * An implementation of a file browser model.
 *
 * #### Notes
 * All paths parameters without a leading `'/'` are interpreted as relative to
 * the current directory.  Supports `'../'` syntax.
 */
var FileBrowserModel = /** @class */ (function () {
    /**
     * Construct a new file browser model.
     */
    function FileBrowserModel(options) {
        this._connectionFailure = new signaling_1.Signal(this);
        this._fileChanged = new signaling_1.Signal(this);
        this._items = [];
        this._key = '';
        this._maxUploadSizeMb = 15;
        this._pathChanged = new signaling_1.Signal(this);
        this._paths = new Set();
        this._pending = null;
        this._pendingPath = null;
        this._refreshed = new signaling_1.Signal(this);
        this._lastRefresh = -1;
        this._requested = false;
        this._sessions = [];
        this._state = null;
        this._timeoutId = -1;
        this._refreshDuration = REFRESH_DURATION;
        this._isDisposed = false;
        this._restored = new coreutils_2.PromiseDelegate();
        this.manager = options.manager;
        this._driveName = options.driveName || '';
        var rootPath = this._driveName ? this._driveName + ':' : '';
        this._model = {
            path: rootPath,
            name: coreutils_1.PathExt.basename(rootPath),
            type: 'directory',
            content: undefined,
            writable: false,
            created: 'unknown',
            last_modified: 'unknown',
            mimetype: 'text/plain',
            format: 'text'
        };
        this._state = options.state || null;
        var services = options.manager.services;
        services.contents.fileChanged.connect(this._onFileChanged, this);
        services.sessions.runningChanged.connect(this._onRunningChanged, this);
        this._scheduleUpdate();
        this._startTimer();
    }
    Object.defineProperty(FileBrowserModel.prototype, "connectionFailure", {
        /**
         * A signal emitted when the file browser model loses connection.
         */
        get: function () {
            return this._connectionFailure;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "restored", {
        /**
         * A promise that resolves when the model is first restored.
         */
        get: function () {
            return this._restored.promise;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "fileChanged", {
        /**
         * Get the file path changed signal.
         */
        get: function () {
            return this._fileChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "path", {
        /**
         * Get the current path.
         */
        get: function () {
            return this._model ? this._model.path : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "pathChanged", {
        /**
         * A signal emitted when the path changes.
         */
        get: function () {
            return this._pathChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "refreshed", {
        /**
         * A signal emitted when the directory listing is refreshed.
         */
        get: function () {
            return this._refreshed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "specs", {
        /**
         * Get the kernel spec models.
         */
        get: function () {
            return this.manager.services.sessions.specs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "isDisposed", {
        /**
         * Get whether the model is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    FileBrowserModel.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        clearTimeout(this._timeoutId);
        this._sessions.length = 0;
        this._items.length = 0;
        signaling_1.Signal.clearData(this);
    };
    /**
     * Create an iterator over the model's items.
     *
     * @returns A new iterator over the model's items.
     */
    FileBrowserModel.prototype.items = function () {
        return new algorithm_1.ArrayIterator(this._items);
    };
    /**
     * Create an iterator over the active sessions in the directory.
     *
     * @returns A new iterator over the model's active sessions.
     */
    FileBrowserModel.prototype.sessions = function () {
        return new algorithm_1.ArrayIterator(this._sessions);
    };
    /**
     * Force a refresh of the directory contents.
     */
    FileBrowserModel.prototype.refresh = function () {
        this._lastRefresh = new Date().getTime();
        this._requested = false;
        return this.cd('.');
    };
    /**
     * Change directory.
     *
     * @param path - The path to the file or directory.
     *
     * @returns A promise with the contents of the directory.
     */
    FileBrowserModel.prototype.cd = function (newValue) {
        var _this = this;
        if (newValue === void 0) { newValue = '.'; }
        if (newValue !== '.') {
            newValue = Private.normalizePath(this.manager.services.contents, this._model.path, newValue);
        }
        else {
            newValue = this._pendingPath || this._model.path;
        }
        // Collapse requests to the same directory.
        if (newValue === this._pendingPath && this._pending) {
            return this._pending;
        }
        var oldValue = this.path;
        var options = { content: true };
        this._pendingPath = newValue;
        if (oldValue !== newValue) {
            this._sessions.length = 0;
        }
        var services = this.manager.services;
        this._pending = services.contents.get(newValue, options).then(function (contents) {
            if (_this.isDisposed) {
                return;
            }
            _this._refreshDuration = REFRESH_DURATION;
            _this._handleContents(contents);
            _this._pendingPath = null;
            if (oldValue !== newValue) {
                // If there is a state database and a unique key, save the new path.
                if (_this._state && _this._key) {
                    _this._state.save(_this._key, { path: newValue });
                }
                _this._pathChanged.emit({
                    name: 'path',
                    oldValue: oldValue,
                    newValue: newValue
                });
            }
            _this._onRunningChanged(services.sessions, services.sessions.running());
            _this._refreshed.emit(void 0);
        }).catch(function (error) {
            _this._pendingPath = null;
            if (error.message === 'Not Found') {
                error.message = "Directory not found: \"" + _this._model.path + "\"";
                console.error(error);
                _this._connectionFailure.emit(error);
                _this.cd('/');
            }
            else {
                _this._refreshDuration = REFRESH_DURATION * 10;
                _this._connectionFailure.emit(error);
            }
        });
        return this._pending;
    };
    /**
     * Download a file.
     *
     * @param path - The path of the file to be downloaded.
     *
     * @returns A promise which resolves when the file has begun
     *   downloading.
     */
    FileBrowserModel.prototype.download = function (path) {
        return this.manager.services.contents.getDownloadUrl(path).then(function (url) {
            var element = document.createElement('a');
            document.body.appendChild(element);
            element.setAttribute('href', url);
            element.setAttribute('download', '');
            element.click();
            document.body.removeChild(element);
            return void 0;
        });
    };
    /**
     * Restore the state of the file browser.
     *
     * @param id - The unique ID that is used to construct a state database key.
     *
     * @returns A promise when restoration is complete.
     *
     * #### Notes
     * This function will only restore the model *once*. If it is called multiple
     * times, all subsequent invocations are no-ops.
     */
    FileBrowserModel.prototype.restore = function (id) {
        var _this = this;
        var state = this._state;
        var restored = !!this._key;
        if (!state || restored) {
            return Promise.resolve(void 0);
        }
        var manager = this.manager;
        var key = "file-browser-" + id + ":cwd";
        var ready = manager.services.ready;
        return Promise.all([state.fetch(key), ready]).then(function (_a) {
            var cwd = _a[0];
            if (!cwd) {
                _this._restored.resolve(void 0);
                return;
            }
            var path = cwd['path'];
            var localPath = manager.services.contents.localPath(path);
            return manager.services.contents.get(path)
                .then(function () { return _this.cd(localPath); })
                .catch(function () { return state.remove(key); });
        }).catch(function () { return state.remove(key); })
            .then(function () {
            _this._key = key;
            _this._restored.resolve(void 0);
        }); // Set key after restoration is done.
    };
    /**
     * Upload a `File` object.
     *
     * @param file - The `File` object to upload.
     *
     * @returns A promise containing the new file contents model.
     *
     * #### Notes
     * This will fail to upload files that are too big to be sent in one
     * request to the server.
     */
    FileBrowserModel.prototype.upload = function (file) {
        var _this = this;
        // Skip large files with a warning.
        if (file.size > this._maxUploadSizeMb * 1024 * 1024) {
            var msg = "Cannot upload file (>" + this._maxUploadSizeMb + " MB) ";
            msg += "\"" + file.name + "\"";
            console.warn(msg);
            return Promise.reject(new Error(msg));
        }
        return this.refresh().then(function () {
            if (_this.isDisposed) {
                return Promise.resolve(false);
            }
            var item = algorithm_1.find(_this._items, function (i) { return i.name === file.name; });
            if (item) {
                return docmanager_1.shouldOverwrite(file.name);
            }
            return Promise.resolve(true);
        }).then(function (value) {
            if (value) {
                return _this._upload(file);
            }
            return Promise.reject('File not uploaded');
        });
    };
    /**
     * Perform the actual upload.
     */
    FileBrowserModel.prototype._upload = function (file) {
        var _this = this;
        // Gather the file model parameters.
        var path = this._model.path;
        path = path ? path + '/' + file.name : file.name;
        var name = file.name;
        var isNotebook = file.name.indexOf('.ipynb') !== -1;
        var type = isNotebook ? 'notebook' : 'file';
        var format = isNotebook ? 'json' : 'base64';
        // Get the file content.
        var reader = new FileReader();
        if (isNotebook) {
            reader.readAsText(file);
        }
        else {
            reader.readAsArrayBuffer(file);
        }
        return new Promise(function (resolve, reject) {
            reader.onload = function (event) {
                var model = {
                    type: type,
                    format: format,
                    name: name,
                    content: Private.getContent(reader)
                };
                _this.manager.services.contents.save(path, model).then(function (contents) {
                    resolve(contents);
                }).catch(reject);
            };
            reader.onerror = function (event) {
                reject(Error("Failed to upload \"" + file.name + "\":" + event));
            };
        });
    };
    /**
     * Handle an updated contents model.
     */
    FileBrowserModel.prototype._handleContents = function (contents) {
        var _this = this;
        // Update our internal data.
        this._model = {
            name: contents.name,
            path: contents.path,
            type: contents.type,
            content: undefined,
            writable: contents.writable,
            created: contents.created,
            last_modified: contents.last_modified,
            mimetype: contents.mimetype,
            format: contents.format
        };
        this._items = contents.content;
        this._paths.clear();
        contents.content.forEach(function (model) {
            _this._paths.add(model.path);
        });
    };
    /**
     * Handle a change to the running sessions.
     */
    FileBrowserModel.prototype._onRunningChanged = function (sender, models) {
        var _this = this;
        this._sessions.length = 0;
        algorithm_1.each(models, function (model) {
            if (_this._paths.has(model.path)) {
                _this._sessions.push(model);
            }
        });
        this._refreshed.emit(void 0);
    };
    /**
     * Handle a change on the contents manager.
     */
    FileBrowserModel.prototype._onFileChanged = function (sender, change) {
        var path = this._model.path;
        var value = change.oldValue;
        if (value && value.path && coreutils_1.PathExt.dirname(value.path) === path) {
            this._fileChanged.emit(change);
            this._scheduleUpdate();
            return;
        }
        value = change.newValue;
        if (value && value.path && coreutils_1.PathExt.dirname(value.path) === path) {
            this._fileChanged.emit(change);
            this._scheduleUpdate();
            return;
        }
    };
    /**
     * Start the internal refresh timer.
     */
    FileBrowserModel.prototype._startTimer = function () {
        var _this = this;
        this._timeoutId = window.setInterval(function () {
            if (_this._requested) {
                _this.refresh();
                return;
            }
            var date = new Date().getTime();
            if ((date - _this._lastRefresh) > _this._refreshDuration) {
                _this.refresh();
            }
        }, MIN_REFRESH);
    };
    /**
     * Handle internal model refresh logic.
     */
    FileBrowserModel.prototype._scheduleUpdate = function () {
        var date = new Date().getTime();
        if ((date - this._lastRefresh) > MIN_REFRESH) {
            this.refresh();
        }
        else {
            this._requested = true;
        }
    };
    return FileBrowserModel;
}());
exports.FileBrowserModel = FileBrowserModel;
/**
 * The namespace for the file browser model private data.
 */
var Private;
(function (Private) {
    /**
     * Parse the content of a `FileReader`.
     *
     * If the result is an `ArrayBuffer`, return a Base64-encoded string.
     * Otherwise, return the JSON parsed result.
     */
    function getContent(reader) {
        if (reader.result instanceof ArrayBuffer) {
            // Base64-encode binary file data.
            var bytes = '';
            var buf = new Uint8Array(reader.result);
            var nbytes = buf.byteLength;
            for (var i = 0; i < nbytes; i++) {
                bytes += String.fromCharCode(buf[i]);
            }
            return btoa(bytes);
        }
        else {
            return JSON.parse(reader.result);
        }
    }
    Private.getContent = getContent;
    /**
     * Normalize a path based on a root directory, accounting for relative paths.
     */
    function normalizePath(contents, root, path) {
        var driveName = contents.driveName(root);
        var localPath = contents.localPath(root);
        var resolved = coreutils_1.PathExt.resolve(localPath, path);
        return driveName ? driveName + ":" + resolved : resolved;
    }
    Private.normalizePath = normalizePath;
})(Private || (Private = {}));
