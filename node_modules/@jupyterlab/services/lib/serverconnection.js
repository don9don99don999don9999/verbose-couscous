"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var FETCH;
var HEADERS;
var REQUEST;
var WEBSOCKET;
if (typeof window === 'undefined') {
    // Mangle the require statements so it does not get picked up in the
    // browser assets.
    /* tslint:disable */
    var fetchMod = eval('require')('node-fetch');
    FETCH = global.fetch || fetchMod;
    REQUEST = global.Request || fetchMod.Request;
    HEADERS = global.Headers || fetchMod.Headers;
    WEBSOCKET = global.WebSocket || eval('require')('ws');
    /* tslint:enable */
}
else {
    FETCH = fetch;
    REQUEST = Request;
    HEADERS = Headers;
    WEBSOCKET = WebSocket;
}
/**
 * The namespace for ServerConnection functions.
 *
 * #### Notes
 * This is only intended to manage communication with the Jupyter server.
 *
 * The default values can be used in a JupyterLab or Jupyter Notebook context.
 *
 * We use `token` authentication if available, falling back on an XSRF
 * cookie if one has been provided on the `document`.
 *
 * A content type of `'application/json'` is added when using authentication
 * and there is no body data to allow the server to prevent malicious forms.
 */
var ServerConnection;
(function (ServerConnection) {
    /**
     * Create a settings object given a subset of options.
     *
     * @param options - An optional partial set of options.
     *
     * @returns The full settings object.
     */
    function makeSettings(options) {
        return Private.makeSettings(options);
    }
    ServerConnection.makeSettings = makeSettings;
    /**
     * Make an request to the notebook server.
     *
     * @param url - The url for the request.
     *
     * @param init - The initialization options for the request.
     *
     * @param settings - The server settings to apply to the request.
     *
     * @returns a Promise that resolves with the response.
     *
     * @throws If the url of the request is not a notebook server url.
     *
     * #### Notes
     * The `url` must start with `settings.baseUrl`.  The `init` settings are
     * merged with `settings.init`, with `init` taking precedence.
     * The headers in the two objects are not merged.
     * If there is no body data, we set the content type to `application/json`
     * because it is required by the Notebook server.
     */
    function makeRequest(url, init, settings) {
        return Private.handleRequest(url, init, settings);
    }
    ServerConnection.makeRequest = makeRequest;
    /**
     * A wrapped error for a fetch response.
     */
    var ResponseError = /** @class */ (function (_super) {
        __extends(ResponseError, _super);
        /**
         * Create a new response error.
         */
        function ResponseError(response, message) {
            var _this = this;
            message = (message ||
                "Invalid response: " + response.status + " " + response.statusText);
            _this = _super.call(this, message) || this;
            _this.response = response;
            return _this;
        }
        return ResponseError;
    }(Error));
    ServerConnection.ResponseError = ResponseError;
    /**
     * A wrapped error for a network error.
     */
    var NetworkError = /** @class */ (function (_super) {
        __extends(NetworkError, _super);
        /**
         * Create a new network error.
         */
        function NetworkError(original) {
            var _this = _super.call(this, original.message) || this;
            _this.stack = original.stack;
            return _this;
        }
        return NetworkError;
    }(TypeError));
    ServerConnection.NetworkError = NetworkError;
    /**
     * The default settings.
     */
    ServerConnection.defaultSettings = {
        baseUrl: coreutils_1.PageConfig.getBaseUrl(),
        pageUrl: coreutils_1.PageConfig.getOption('pageUrl'),
        wsUrl: coreutils_1.PageConfig.getWsUrl(),
        token: coreutils_1.PageConfig.getToken(),
        init: { 'cache': 'no-store', 'credentials': 'same-origin' },
        fetch: FETCH,
        Headers: HEADERS,
        Request: REQUEST,
        WebSocket: WEBSOCKET
    };
})(ServerConnection = exports.ServerConnection || (exports.ServerConnection = {}));
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Handle the server connection settings, returning a new value.
     */
    function makeSettings(options) {
        if (options === void 0) { options = {}; }
        return __assign({}, ServerConnection.defaultSettings, options);
    }
    Private.makeSettings = makeSettings;
    /**
     * Handle a request.
     *
     * @param url - The url for the request.
     *
     * @param init - The overrides for the request init.
     *
     * @param settings - The settings object for the request.
     *
     * #### Notes
     * The `url` must start with `settings.baseUrl`.  The `init` settings
     * take precedence over `settings.init`.
     */
    function handleRequest(url, init, settings) {
        // Handle notebook server requests.
        if (url.indexOf(settings.baseUrl) !== 0) {
            throw new Error('Can only be used for notebook server requests');
        }
        // Use explicit cache buster when `no-store` is set since
        // not all browsers use it properly.
        var cache = init.cache || settings.init.cache;
        if (cache === 'no-store') {
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
            url += ((/\?/).test(url) ? '&' : '?') + (new Date()).getTime();
        }
        var request = new settings.Request(url, __assign({}, settings.init, init));
        // Handle authentication.
        var authenticated = false;
        if (settings.token) {
            authenticated = true;
            request.headers.append('Authorization', "token " + settings.token);
        }
        else if (typeof document !== 'undefined' && document.cookie) {
            var xsrfToken = getCookie('_xsrf');
            if (xsrfToken !== void 0) {
                authenticated = true;
                request.headers.append('X-XSRFToken', xsrfToken);
            }
        }
        // Set the content type if there is no given data and we are
        // using an authenticated connection.
        if (!request.bodyUsed && authenticated) {
            request.headers.set('Content-Type', 'application/json');
        }
        // Use `call` to avoid a `TypeError` in the browser.
        return settings.fetch.call(null, request).catch(function (e) {
            // Convert the TypeError into a more specific error.
            throw new ServerConnection.NetworkError(e);
        });
    }
    Private.handleRequest = handleRequest;
    /**
     * Get a cookie from the document.
     */
    function getCookie(name) {
        // from tornado docs: http://www.tornadoweb.org/en/stable/guide/security.html
        var r = document.cookie.match('\\b' + name + '=([^;]*)\\b');
        return r ? r[1] : void 0;
    }
})(Private || (Private = {}));
