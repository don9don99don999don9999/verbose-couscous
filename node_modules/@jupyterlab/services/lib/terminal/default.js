"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var algorithm_1 = require("@phosphor/algorithm");
var signaling_1 = require("@phosphor/signaling");
var __1 = require("..");
var terminal_1 = require("./terminal");
/**
 * The url for the terminal service.
 */
var TERMINAL_SERVICE_URL = 'api/terminals';
/**
 * An implementation of a terminal interface.
 */
var DefaultTerminalSession = /** @class */ (function () {
    /**
     * Construct a new terminal session.
     */
    function DefaultTerminalSession(name, options) {
        if (options === void 0) { options = {}; }
        this._isDisposed = false;
        this._isReady = false;
        this._messageReceived = new signaling_1.Signal(this);
        this._terminated = new signaling_1.Signal(this);
        this._ws = null;
        this._noOp = function () { };
        this._name = name;
        this.serverSettings = options.serverSettings || __1.ServerConnection.makeSettings();
        this._readyPromise = this._initializeSocket();
    }
    Object.defineProperty(DefaultTerminalSession.prototype, "terminated", {
        /**
         * A signal emitted when the session is shut down.
         */
        get: function () {
            return this._terminated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "messageReceived", {
        /**
         * A signal emitted when a message is received from the server.
         */
        get: function () {
            return this._messageReceived;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "name", {
        /**
         * Get the name of the terminal session.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "model", {
        /**
         * Get the model for the terminal session.
         */
        get: function () {
            return { name: this._name };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isReady", {
        /**
         * Test whether the session is ready.
         */
        get: function () {
            return this._isReady;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "ready", {
        /**
         * A promise that fulfills when the session is ready.
         */
        get: function () {
            return this._readyPromise;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isDisposed", {
        /**
         * Test whether the session is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the session.
     */
    DefaultTerminalSession.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this.terminated.emit(void 0);
        this._isDisposed = true;
        if (this._ws) {
            this._ws.close();
            this._ws = null;
        }
        delete Private.running[this._url];
        signaling_1.Signal.clearData(this);
    };
    /**
     * Send a message to the terminal session.
     */
    DefaultTerminalSession.prototype.send = function (message) {
        var _this = this;
        if (this._isDisposed || !message.content) {
            return;
        }
        var msg = [message.type].concat(message.content);
        var socket = this._ws;
        var value = JSON.stringify(msg);
        if (this._isReady && socket) {
            socket.send(value);
            return;
        }
        this.ready.then(function () {
            var socket = _this._ws;
            if (socket) {
                socket.send(value);
            }
        });
    };
    /**
     * Reconnect to the terminal.
     *
     * @returns A promise that resolves when the terminal has reconnected.
     */
    DefaultTerminalSession.prototype.reconnect = function () {
        this._readyPromise = this._initializeSocket();
        return this._readyPromise;
    };
    /**
     * Shut down the terminal session.
     */
    DefaultTerminalSession.prototype.shutdown = function () {
        var _a = this, name = _a.name, serverSettings = _a.serverSettings;
        return DefaultTerminalSession.shutdown(name, serverSettings);
    };
    /**
     * Clone the current session object.
     */
    DefaultTerminalSession.prototype.clone = function () {
        var _a = this, name = _a.name, serverSettings = _a.serverSettings;
        return new DefaultTerminalSession(name, { serverSettings: serverSettings });
    };
    /**
     * Connect to the websocket.
     */
    DefaultTerminalSession.prototype._initializeSocket = function () {
        var _this = this;
        var name = this._name;
        var socket = this._ws;
        if (socket) {
            // Clear the websocket event handlers and the socket itself.
            socket.onopen = this._noOp;
            socket.onclose = this._noOp;
            socket.onerror = this._noOp;
            socket.onmessage = this._noOp;
            socket.close();
            this._ws = null;
        }
        this._isReady = false;
        return new Promise(function (resolve, reject) {
            var settings = _this.serverSettings;
            var token = _this.serverSettings.token;
            _this._url = Private.getTermUrl(settings.baseUrl, _this._name);
            Private.running[_this._url] = _this;
            var wsUrl = coreutils_1.URLExt.join(settings.wsUrl, "terminals/websocket/" + name);
            if (token) {
                wsUrl = wsUrl + ("?token=" + token);
            }
            socket = _this._ws = new settings.WebSocket(wsUrl);
            socket.onmessage = function (event) {
                if (_this._isDisposed) {
                    return;
                }
                var data = JSON.parse(event.data);
                _this._messageReceived.emit({
                    type: data[0],
                    content: data.slice(1)
                });
            };
            socket.onopen = function (event) {
                if (!_this._isDisposed) {
                    _this._isReady = true;
                    resolve(undefined);
                }
            };
            socket.onerror = function (event) {
                if (!_this._isDisposed) {
                    reject(event);
                }
            };
        });
    };
    return DefaultTerminalSession;
}());
exports.DefaultTerminalSession = DefaultTerminalSession;
/**
 * The static namespace for `DefaultTerminalSession`.
 */
(function (DefaultTerminalSession) {
    /**
     * Whether the terminal service is available.
     */
    function isAvailable() {
        var available = String(coreutils_1.PageConfig.getOption('terminalsAvailable'));
        return available.toLowerCase() === 'true';
    }
    DefaultTerminalSession.isAvailable = isAvailable;
    /**
     * Start a new terminal session.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves with the session instance.
     */
    function startNew(options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            throw Private.unavailableMsg;
        }
        var serverSettings = options.serverSettings || __1.ServerConnection.makeSettings();
        var url = Private.getServiceUrl(serverSettings.baseUrl);
        var init = { method: 'POST' };
        return __1.ServerConnection.makeRequest(url, init, serverSettings).then(function (response) {
            if (response.status !== 200) {
                throw new __1.ServerConnection.ResponseError(response);
            }
            return response.json();
        }).then(function (data) {
            var name = data.name;
            return new DefaultTerminalSession(name, __assign({}, options, { serverSettings: serverSettings }));
        });
    }
    DefaultTerminalSession.startNew = startNew;
    /*
     * Connect to a running session.
     *
     * @param name - The name of the target session.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves with the new session instance.
     *
     * #### Notes
     * If the session was already started via `startNew`, the existing
     * session object is used as the fulfillment value.
     *
     * Otherwise, if `options` are given, we resolve the promise after
     * confirming that the session exists on the server.
     *
     * If the session does not exist on the server, the promise is rejected.
     */
    function connectTo(name, options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        var serverSettings = options.serverSettings || __1.ServerConnection.makeSettings();
        var url = Private.getTermUrl(serverSettings.baseUrl, name);
        if (url in Private.running) {
            return Promise.resolve(Private.running[url].clone());
        }
        return listRunning(serverSettings).then(function (models) {
            var index = algorithm_1.ArrayExt.findFirstIndex(models, function (model) {
                return model.name === name;
            });
            if (index !== -1) {
                var session = new DefaultTerminalSession(name, __assign({}, options, { serverSettings: serverSettings }));
                return Promise.resolve(session);
            }
            return Promise.reject('Could not find session');
        });
    }
    DefaultTerminalSession.connectTo = connectTo;
    /**
     * List the running terminal sessions.
     *
     * @param settings - The server settings to use.
     *
     * @returns A promise that resolves with the list of running session models.
     */
    function listRunning(settings) {
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        settings = settings || __1.ServerConnection.makeSettings();
        var url = Private.getServiceUrl(settings.baseUrl);
        return __1.ServerConnection.makeRequest(url, {}, settings).then(function (response) {
            if (response.status !== 200) {
                throw new __1.ServerConnection.ResponseError(response);
            }
            return response.json();
        }).then(function (data) {
            if (!Array.isArray(data)) {
                throw new Error('Invalid terminal data');
            }
            // Update the local data store.
            var urls = algorithm_1.toArray(algorithm_1.map(data, function (item) {
                return coreutils_1.URLExt.join(url, item.name);
            }));
            algorithm_1.each(Object.keys(Private.running), function (runningUrl) {
                if (urls.indexOf(runningUrl) === -1) {
                    var session = Private.running[runningUrl];
                    session.dispose();
                }
            });
            return data;
        });
    }
    DefaultTerminalSession.listRunning = listRunning;
    /**
     * Shut down a terminal session by name.
     *
     * @param name - The name of the target session.
     *
     * @param settings - The server settings to use.
     *
     * @returns A promise that resolves when the session is shut down.
     */
    function shutdown(name, settings) {
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        settings = settings || __1.ServerConnection.makeSettings();
        var url = Private.getTermUrl(settings.baseUrl, name);
        var init = { method: 'DELETE' };
        return __1.ServerConnection.makeRequest(url, init, settings).then(function (response) {
            if (response.status === 404) {
                return response.json().then(function (data) {
                    console.warn(data['message']);
                    Private.killTerminal(url);
                });
            }
            if (response.status !== 204) {
                throw new __1.ServerConnection.ResponseError(response);
            }
            Private.killTerminal(url);
        });
    }
    DefaultTerminalSession.shutdown = shutdown;
    /**
     * Shut down all terminal sessions.
     *
     * @param settings - The server settings to use.
     *
     * @returns A promise that resolves when all the sessions are shut down.
     */
    function shutdownAll(settings) {
        settings = settings || __1.ServerConnection.makeSettings();
        return listRunning(settings).then(function (running) {
            algorithm_1.each(running, function (s) {
                shutdown(s.name, settings);
            });
        });
    }
    DefaultTerminalSession.shutdownAll = shutdownAll;
})(DefaultTerminalSession = exports.DefaultTerminalSession || (exports.DefaultTerminalSession = {}));
exports.DefaultTerminalSession = DefaultTerminalSession;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * A mapping of running terminals by url.
     */
    Private.running = Object.create(null);
    /**
     * A promise returned for when terminals are unavailable.
     */
    Private.unavailableMsg = 'Terminals Unavailable';
    /**
     * Get the url for a terminal.
     */
    function getTermUrl(baseUrl, name) {
        return coreutils_1.URLExt.join(baseUrl, TERMINAL_SERVICE_URL, name);
    }
    Private.getTermUrl = getTermUrl;
    /**
     * Get the base url.
     */
    function getServiceUrl(baseUrl) {
        return coreutils_1.URLExt.join(baseUrl, TERMINAL_SERVICE_URL);
    }
    Private.getServiceUrl = getServiceUrl;
    /**
     * Kill a terminal by url.
     */
    function killTerminal(url) {
        // Update the local data store.
        if (Private.running[url]) {
            var session = Private.running[url];
            session.dispose();
        }
    }
    Private.killTerminal = killTerminal;
})(Private || (Private = {}));
