"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var signaling_1 = require("@phosphor/signaling");
/**
 * A class that manages the auto saving of a document.
 *
 * #### Notes
 * Implements https://github.com/ipython/ipython/wiki/IPEP-15:-Autosaving-the-IPython-Notebook.
 */
var SaveHandler = /** @class */ (function () {
    /**
     * Construct a new save handler.
     */
    function SaveHandler(options) {
        this._autosaveTimer = -1;
        this._minInterval = -1;
        this._interval = -1;
        this._isActive = false;
        this._inDialog = false;
        this._isDisposed = false;
        this._multiplier = 10;
        this._context = options.context;
        var interval = options.saveInterval || 120;
        this._minInterval = interval * 1000;
        this._interval = this._minInterval;
        // Restart the timer when the contents model is updated.
        this._context.fileChanged.connect(this._setTimer, this);
        this._context.disposed.connect(this.dispose, this);
    }
    Object.defineProperty(SaveHandler.prototype, "saveInterval", {
        /**
         * The save interval used by the timer (in seconds).
         */
        get: function () {
            return this._interval / 1000;
        },
        set: function (value) {
            this._minInterval = this._interval = value * 1000;
            if (this._isActive) {
                this._setTimer();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SaveHandler.prototype, "isActive", {
        /**
         * Get whether the handler is active.
         */
        get: function () {
            return this._isActive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SaveHandler.prototype, "isDisposed", {
        /**
         * Get whether the save handler is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the save handler.
     */
    SaveHandler.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        clearTimeout(this._autosaveTimer);
        signaling_1.Signal.clearData(this);
    };
    /**
     * Start the autosaver.
     */
    SaveHandler.prototype.start = function () {
        this._isActive = true;
        this._setTimer();
    };
    /**
     * Stop the autosaver.
     */
    SaveHandler.prototype.stop = function () {
        this._isActive = false;
        clearTimeout(this._autosaveTimer);
    };
    /**
     * Set the timer.
     */
    SaveHandler.prototype._setTimer = function () {
        var _this = this;
        clearTimeout(this._autosaveTimer);
        if (!this._isActive) {
            return;
        }
        this._autosaveTimer = window.setTimeout(function () {
            _this._save();
        }, this._interval);
    };
    /**
     * Handle an autosave timeout.
     */
    SaveHandler.prototype._save = function () {
        var _this = this;
        var context = this._context;
        // Trigger the next update.
        this._setTimer();
        if (!context) {
            return;
        }
        // Bail if the model is not dirty or the file is not writable, or the dialog
        // is already showing.
        var writable = context.contentsModel && context.contentsModel.writable;
        if (!writable || !context.model.dirty || this._inDialog) {
            return;
        }
        var start = new Date().getTime();
        context.save().then(function () {
            if (_this.isDisposed) {
                return;
            }
            var duration = new Date().getTime() - start;
            // New save interval: higher of 10x save duration or min interval.
            _this._interval = Math.max(_this._multiplier * duration, _this._minInterval);
            // Restart the update to pick up the new interval.
            _this._setTimer();
        }).catch(function (err) {
            console.error('Error in Auto-Save', err.message);
        });
    };
    return SaveHandler;
}());
exports.SaveHandler = SaveHandler;
