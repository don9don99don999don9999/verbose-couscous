"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var docregistry_1 = require("@jupyterlab/docregistry");
var algorithm_1 = require("@phosphor/algorithm");
var coreutils_2 = require("@phosphor/coreutils");
var properties_1 = require("@phosphor/properties");
var signaling_1 = require("@phosphor/signaling");
var savehandler_1 = require("./savehandler");
var widgetmanager_1 = require("./widgetmanager");
/* tslint:disable */
/**
 * The document registry token.
 */
exports.IDocumentManager = new coreutils_2.Token('@jupyterlab/docmanager:IDocumentManager');
/**
 * The document manager.
 *
 * #### Notes
 * The document manager is used to register model and widget creators,
 * and the file browser uses the document manager to create widgets. The
 * document manager maintains a context for each path and model type that is
 * open, and a list of widgets for each context. The document manager is in
 * control of the proper closing and disposal of the widgets and contexts.
 */
var DocumentManager = /** @class */ (function () {
    /**
     * Construct a new document manager.
     */
    function DocumentManager(options) {
        this._activateRequested = new signaling_1.Signal(this);
        this._contexts = [];
        this._isDisposed = false;
        this._autosave = true;
        this.registry = options.registry;
        this.services = options.manager;
        this._opener = options.opener;
        var widgetManager = new widgetmanager_1.DocumentWidgetManager({ registry: this.registry });
        widgetManager.activateRequested.connect(this._onActivateRequested, this);
        this._widgetManager = widgetManager;
    }
    Object.defineProperty(DocumentManager.prototype, "activateRequested", {
        /**
         * A signal emitted when one of the documents is activated.
         */
        get: function () {
            return this._activateRequested;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentManager.prototype, "autosave", {
        /**
         * Whether to autosave documents.
         */
        get: function () {
            return this._autosave;
        },
        set: function (value) {
            this._autosave = value;
            this._contexts.forEach(function (context) {
                var handler = Private.saveHandlerProperty.get(context);
                if (value === true && !handler.isActive) {
                    handler.start();
                }
                else if (value === false && handler.isActive) {
                    handler.stop();
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentManager.prototype, "isDisposed", {
        /**
         * Get whether the document manager has been disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the document manager.
     */
    DocumentManager.prototype.dispose = function () {
        var _this = this;
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this._contexts.forEach(function (context) {
            _this._widgetManager.closeWidgets(context);
        });
        this._widgetManager.dispose();
        this._contexts.length = 0;
    };
    /**
     * Clone a widget.
     *
     * @param widget - The source widget.
     *
     * @returns A new widget or `undefined`.
     *
     * #### Notes
     *  Uses the same widget factory and context as the source, or returns
     *  `undefined` if the source widget is not managed by this manager.
     */
    DocumentManager.prototype.cloneWidget = function (widget) {
        return this._widgetManager.cloneWidget(widget);
    };
    /**
     * Close all of the open documents.
     */
    DocumentManager.prototype.closeAll = function () {
        var _this = this;
        return Promise.all(algorithm_1.toArray(algorithm_1.map(this._contexts, function (context) {
            return _this._widgetManager.closeWidgets(context);
        }))).then(function () { return undefined; });
    };
    /**
     * Close the widgets associated with a given path.
     *
     * @param path - The target path.
     */
    DocumentManager.prototype.closeFile = function (path) {
        var context = this._contextForPath(path);
        if (context) {
            return this._widgetManager.closeWidgets(context);
        }
        return Promise.resolve(void 0);
    };
    /**
     * Get the document context for a widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The context associated with the widget, or `undefined`.
     */
    DocumentManager.prototype.contextForWidget = function (widget) {
        return this._widgetManager.contextForWidget(widget);
    };
    /**
     * Copy a file.
     *
     * @param fromFile - The full path of the original file.
     *
     * @param toDir - The full path to the target directory.
     *
     * @returns A promise which resolves to the contents of the file.
     */
    DocumentManager.prototype.copy = function (fromFile, toDir) {
        return this.services.contents.copy(fromFile, toDir);
    };
    /**
     * Create a new file and return the widget used to view it.
     *
     * @param path - The file path to create.
     *
     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.
     *
     * @param kernel - An optional kernel name/id to override the default.
     *
     * @returns The created widget, or `undefined`.
     *
     * #### Notes
     * This function will return `undefined` if a valid widget factory
     * cannot be found.
     */
    DocumentManager.prototype.createNew = function (path, widgetName, kernel) {
        if (widgetName === void 0) { widgetName = 'default'; }
        return this._createOrOpenDocument('create', path, widgetName, kernel);
    };
    /**
     * Delete a file.
     *
     * @param path - The full path to the file to be deleted.
     *
     * @returns A promise which resolves when the file is deleted.
     *
     * #### Notes
     * If there is a running session associated with the file and no other
     * sessions are using the kernel, the session will be shut down.
     */
    DocumentManager.prototype.deleteFile = function (path) {
        var _this = this;
        return this.services.sessions.stopIfNeeded(path).then(function () {
            return _this.services.contents.delete(path);
        })
            .then(function () {
            var context = _this._contextForPath(path);
            if (context) {
                return _this._widgetManager.deleteWidgets(context);
            }
            return Promise.resolve(void 0);
        });
    };
    /**
     * See if a widget already exists for the given path and widget name.
     *
     * @param path - The file path to use.
     *
     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.
     *
     * @returns The found widget, or `undefined`.
     *
     * #### Notes
     * This can be used to use an existing widget instead of opening
     * a new widget.
     */
    DocumentManager.prototype.findWidget = function (path, widgetName) {
        if (widgetName === void 0) { widgetName = 'default'; }
        if (widgetName === 'default') {
            var factory = this.registry.defaultWidgetFactory(path);
            if (!factory) {
                return undefined;
            }
            widgetName = factory.name;
        }
        var context = this._contextForPath(path);
        if (context) {
            return this._widgetManager.findWidget(context, widgetName);
        }
        return undefined;
    };
    /**
     * Create a new untitled file.
     *
     * @param options - The file content creation options.
     */
    DocumentManager.prototype.newUntitled = function (options) {
        if (options.type === 'file') {
            options.ext = options.ext || '.txt';
        }
        return this.services.contents.newUntitled(options);
    };
    /**
     * Open a file and return the widget used to view it.
     *
     * @param path - The file path to open.
     *
     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.
     *
     * @param kernel - An optional kernel name/id to override the default.
     *
     * @returns The created widget, or `undefined`.
     *
     * #### Notes
     * This function will return `undefined` if a valid widget factory
     * cannot be found.
     */
    DocumentManager.prototype.open = function (path, widgetName, kernel, options) {
        if (widgetName === void 0) { widgetName = 'default'; }
        return this._createOrOpenDocument('open', path, widgetName, kernel, options);
    };
    /**
     * Open a file and return the widget used to view it.
     * Reveals an already existing editor.
     *
     * @param path - The file path to open.
     *
     * @param widgetName - The name of the widget factory to use. 'default' will use the default widget.
     *
     * @param kernel - An optional kernel name/id to override the default.
     *
     * @returns The created widget, or `undefined`.
     *
     * #### Notes
     * This function will return `undefined` if a valid widget factory
     * cannot be found.
     */
    DocumentManager.prototype.openOrReveal = function (path, widgetName, kernel, options) {
        if (widgetName === void 0) { widgetName = 'default'; }
        var widget = this.findWidget(path, widgetName);
        if (widget) {
            this._opener.open(widget, options || {});
            return widget;
        }
        return this.open(path, widgetName, kernel, options || {});
    };
    /**
     * Overwrite a file.
     *
     * @param oldPath - The full path to the original file.
     *
     * @param newPath - The full path to the new file.
     *
     * @returns A promise containing the new file contents model.
     */
    DocumentManager.prototype.overwrite = function (oldPath, newPath) {
        var _this = this;
        // Cleanly overwrite the file by moving it, making sure the original does
        // not exist, and then renaming to the new path.
        var tempPath = newPath + "." + coreutils_1.uuid();
        var cb = function () { return _this.rename(tempPath, newPath); };
        return this.rename(oldPath, tempPath).then(function () {
            return _this.deleteFile(newPath);
        }).then(cb, cb);
    };
    /**
     * Rename a file or directory.
     *
     * @param oldPath - The full path to the original file.
     *
     * @param newPath - The full path to the new file.
     *
     * @returns A promise containing the new file contents model.  The promise
     * will reject if the newPath already exists.  Use [[overwrite]] to overwrite
     * a file.
     */
    DocumentManager.prototype.rename = function (oldPath, newPath) {
        return this.services.contents.rename(oldPath, newPath);
    };
    /**
     * Find a context for a given path and factory name.
     */
    DocumentManager.prototype._findContext = function (path, factoryName) {
        return algorithm_1.find(this._contexts, function (context) {
            return context.factoryName === factoryName && context.path === path;
        });
    };
    /**
     * Get a context for a given path.
     */
    DocumentManager.prototype._contextForPath = function (path) {
        return algorithm_1.find(this._contexts, function (context) { return context.path === path; });
    };
    /**
     * Create a context from a path and a model factory.
     */
    DocumentManager.prototype._createContext = function (path, factory, kernelPreference) {
        var _this = this;
        // Allow options to be passed when adding a sibling.
        var adopter = function (widget, options) {
            _this._widgetManager.adoptWidget(context, widget);
            _this._opener.open(widget, options);
        };
        var modelDBFactory = this.services.contents.getModelDBFactory(path) || undefined;
        var context = new docregistry_1.Context({
            opener: adopter,
            manager: this.services,
            factory: factory,
            path: path,
            kernelPreference: kernelPreference,
            modelDBFactory: modelDBFactory
        });
        var handler = new savehandler_1.SaveHandler({ context: context });
        Private.saveHandlerProperty.set(context, handler);
        context.ready.then(function () {
            if (_this.autosave) {
                handler.start();
            }
        });
        context.disposed.connect(this._onContextDisposed, this);
        this._contexts.push(context);
        return context;
    };
    /**
     * Handle a context disposal.
     */
    DocumentManager.prototype._onContextDisposed = function (context) {
        algorithm_1.ArrayExt.removeFirstOf(this._contexts, context);
    };
    /**
     * Get the widget factory for a given widget name.
     */
    DocumentManager.prototype._widgetFactoryFor = function (path, widgetName) {
        var registry = this.registry;
        if (widgetName === 'default') {
            var factory = registry.defaultWidgetFactory(path);
            if (!factory) {
                return undefined;
            }
            widgetName = factory.name;
        }
        return registry.getWidgetFactory(widgetName);
    };
    /**
     * Creates a new document, or loads one from disk, depending on the `which` argument.
     * If `which==='create'`, then it creates a new document. If `which==='open'`,
     * then it loads the document from disk.
     *
     * The two cases differ in how the document context is handled, but the creation
     * of the widget and launching of the kernel are identical.
     */
    DocumentManager.prototype._createOrOpenDocument = function (which, path, widgetName, kernel, options) {
        if (widgetName === void 0) { widgetName = 'default'; }
        var widgetFactory = this._widgetFactoryFor(path, widgetName);
        if (!widgetFactory) {
            return undefined;
        }
        var modelName = widgetFactory.modelName || 'text';
        var factory = this.registry.getModelFactory(modelName);
        if (!factory) {
            return undefined;
        }
        // Handle the kernel pereference.
        var preference = this.registry.getKernelPreference(path, widgetFactory.name, kernel);
        var context = null;
        var ready = null;
        // Handle the load-from-disk case
        if (which === 'open') {
            // Use an existing context if available.
            context = this._findContext(path, factory.name) || null;
            if (!context) {
                context = this._createContext(path, factory, preference);
                // Populate the model, either from disk or a
                // model backend.
                ready = context.fromStore();
            }
        }
        else if (which === 'create') {
            context = this._createContext(path, factory, preference);
            // Immediately save the contents to disk.
            ready = context.save();
        }
        var widget = this._widgetManager.createWidget(widgetFactory, context);
        this._opener.open(widget, options || {});
        // If the initial opening of the context fails, dispose of the widget.
        ready.catch(function (err) { widget.close(); });
        return widget;
    };
    /**
     * Handle an activateRequested signal from the widget manager.
     */
    DocumentManager.prototype._onActivateRequested = function (sender, args) {
        this._activateRequested.emit(args);
    };
    return DocumentManager;
}());
exports.DocumentManager = DocumentManager;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for a context save handler.
     */
    Private.saveHandlerProperty = new properties_1.AttachedProperty({
        name: 'saveHandler',
        create: function () { return undefined; }
    });
})(Private || (Private = {}));
