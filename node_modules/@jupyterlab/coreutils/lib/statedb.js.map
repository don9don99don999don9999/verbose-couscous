{"version":3,"file":"statedb.js","sourceRoot":"","sources":["../../../../coreutils/src/statedb.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  ReadonlyJSONObject, ReadonlyJSONValue, Token\n} from '@phosphor/coreutils';\n\nimport {\n  ISignal, Signal\n} from '@phosphor/signaling';\n\nimport {\n  IDataConnector\n} from './interfaces';\n\n\n/* tslint:disable */\n/**\n * The default state database token.\n */\nexport\nconst IStateDB = new Token<IStateDB>('@jupyterlab/coreutils:IStateDB');\n/* tslint:enable */\n\n\n/**\n * An object which holds an id/value pair.\n */\nexport\ninterface IStateItem {\n  /**\n   * The identifier key for a state item.\n   */\n  id: string;\n\n  /**\n   * The data value for a state item.\n   */\n  value: ReadonlyJSONValue;\n}\n\n\n/**\n * The description of a state database.\n */\nexport\ninterface IStateDB extends IDataConnector<ReadonlyJSONValue> {\n  /**\n   * The maximum allowed length of the data after it has been serialized.\n   */\n  readonly maxLength: number;\n\n  /**\n   * The namespace prefix for all state database entries.\n   *\n   * #### Notes\n   * This value should be set at instantiation and will only be used\n   * internally by a state database. That means, for example, that an\n   * app could have multiple, mutually exclusive state databases.\n   */\n  readonly namespace: string;\n\n  /**\n   * Retrieve all the saved bundles for a namespace.\n   *\n   * @param namespace - The namespace to retrieve.\n   *\n   * @returns A promise that bears a collection data payloads for a namespace.\n   *\n   * #### Notes\n   * Namespaces are entirely conventional entities. The `id` values of stored\n   * items in the state database are formatted: `'namespace:identifier'`, which\n   * is the same convention that command identifiers in JupyterLab use as well.\n   *\n   * If there are any errors in retrieving the data, they will be logged to the\n   * console in order to optimistically return any extant data without failing.\n   * This promise will always succeed.\n   */\n  fetchNamespace(namespace: string): Promise<IStateItem[]>;\n\n  /**\n   * Return a serialized copy of the state database's entire contents.\n   *\n   * @returns A promise that bears the database contents as JSON.\n   */\n  toJSON(): Promise<ReadonlyJSONObject>;\n}\n\n\n/**\n * The default concrete implementation of a state database.\n */\nexport\nclass StateDB implements IStateDB {\n  /**\n   * Create a new state database.\n   *\n   * @param options - The instantiation options for a state database.\n   */\n  constructor(options: StateDB.IOptions) {\n    const { namespace, transform } = options;\n\n    this.namespace = namespace;\n\n    if (!transform) {\n      this._ready = Promise.resolve(undefined);\n      return;\n    }\n\n    this._ready = transform.then(transformation => {\n      const { contents, type } = transformation;\n\n      switch (type) {\n        case 'cancel':\n          return;\n        case 'clear':\n          this._clear();\n          return;\n        case 'merge':\n          this._merge(contents || { });\n          return;\n        case 'overwrite':\n          this._overwrite(contents || { });\n          return;\n        default:\n          return;\n      }\n    });\n  }\n\n  get changed(): ISignal<this, StateDB.Change> {\n    return this._changed;\n  }\n\n  /**\n   * The maximum allowed length of the data after it has been serialized.\n   */\n  readonly maxLength = 2000;\n\n  /**\n   * The namespace prefix for all state database entries.\n   *\n   * #### Notes\n   * This value should be set at instantiation and will only be used internally\n   * by a state database. That means, for example, that an app could have\n   * multiple, mutually exclusive state databases.\n   */\n  readonly namespace: string;\n\n  /**\n   * Clear the entire database.\n   */\n  clear(silent = false): Promise<void> {\n    return this._ready.then(() => {\n      this._clear();\n\n      if (silent) {\n        return;\n      }\n\n      this._changed.emit({ id: null, type: 'clear' });\n    });\n  }\n\n  /**\n   * Retrieve a saved bundle from the database.\n   *\n   * @param id - The identifier used to retrieve a data bundle.\n   *\n   * @returns A promise that bears a data payload if available.\n   *\n   * #### Notes\n   * The `id` values of stored items in the state database are formatted:\n   * `'namespace:identifier'`, which is the same convention that command\n   * identifiers in JupyterLab use as well. While this is not a technical\n   * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n   * using the `fetchNamespace()` method.\n   *\n   * The promise returned by this method may be rejected if an error occurs in\n   * retrieving the data. Non-existence of an `id` will succeed with `null`.\n   */\n  fetch(id: string): Promise<ReadonlyJSONValue | undefined> {\n    return this._ready.then(() => {\n      const key = `${this.namespace}:${id}`;\n      const value = window.localStorage.getItem(key);\n\n      if (value) {\n        const envelope = JSON.parse(value) as Private.Envelope;\n\n        return envelope.v;\n      }\n    });\n  }\n\n  /**\n   * Retrieve all the saved bundles for a namespace.\n   *\n   * @param namespace - The namespace to retrieve.\n   *\n   * @returns A promise that bears a collection data payloads for a namespace.\n   *\n   * #### Notes\n   * Namespaces are entirely conventional entities. The `id` values of stored\n   * items in the state database are formatted: `'namespace:identifier'`, which\n   * is the same convention that command identifiers in JupyterLab use as well.\n   *\n   * If there are any errors in retrieving the data, they will be logged to the\n   * console in order to optimistically return any extant data without failing.\n   * This promise will always succeed.\n   */\n  fetchNamespace(namespace: string): Promise<IStateItem[]> {\n    return this._ready.then(() => {\n      const { localStorage } = window;\n      const prefix = `${this.namespace}:${namespace}:`;\n      let items: IStateItem[] = [];\n      let i = localStorage.length;\n\n      while (i) {\n        let key = localStorage.key(--i);\n\n        if (key && key.indexOf(prefix) === 0) {\n          let value = localStorage.getItem(key);\n\n          try {\n            let envelope = JSON.parse(value) as Private.Envelope;\n\n            items.push({\n              id: key.replace(`${this.namespace}:`, ''),\n              value: envelope ? envelope.v : undefined\n            });\n          } catch (error) {\n            console.warn(error);\n            localStorage.removeItem(key);\n          }\n        }\n      }\n\n      return items;\n    });\n  }\n\n  /**\n   * Remove a value from the database.\n   *\n   * @param id - The identifier for the data being removed.\n   *\n   * @returns A promise that is rejected if remove fails and succeeds otherwise.\n   */\n  remove(id: string): Promise<void> {\n    return this._ready.then(() => {\n      window.localStorage.removeItem(`${this.namespace}:${id}`);\n      this._changed.emit({ id, type: 'remove' });\n    });\n  }\n\n  /**\n   * Save a value in the database.\n   *\n   * @param id - The identifier for the data being saved.\n   *\n   * @param value - The data being saved.\n   *\n   * @returns A promise that is rejected if saving fails and succeeds otherwise.\n   *\n   * #### Notes\n   * The `id` values of stored items in the state database are formatted:\n   * `'namespace:identifier'`, which is the same convention that command\n   * identifiers in JupyterLab use as well. While this is not a technical\n   * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n   * using the `fetchNamespace()` method.\n   */\n  save(id: string, value: ReadonlyJSONValue): Promise<void> {\n    return this._ready.then(() => {\n      this._save(id, value);\n      this._changed.emit({ id, type: 'save' });\n    });\n  }\n\n  /**\n   * Return a serialized copy of the state database's entire contents.\n   *\n   * @returns A promise that bears the database contents as JSON.\n   */\n  toJSON(): Promise<ReadonlyJSONObject> {\n    return this._ready.then(() => {\n      const { localStorage } = window;\n      const prefix = `${this.namespace}:`;\n      const contents: Partial<ReadonlyJSONObject> =  { };\n      let i = localStorage.length;\n\n      while (i) {\n        let key = localStorage.key(--i);\n\n        if (key && key.indexOf(prefix) === 0) {\n          let value = localStorage.getItem(key);\n\n          try {\n            let envelope = JSON.parse(value) as Private.Envelope;\n\n            if (envelope) {\n              contents[key.replace(prefix, '')] = envelope.v;\n            }\n          } catch (error) {\n            console.warn(error);\n            localStorage.removeItem(key);\n          }\n        }\n      }\n\n      return contents;\n    });\n  }\n\n  /**\n   * Clear the entire database.\n   *\n   * #### Notes\n   * Unlike the public `clear` method, this method is synchronous.\n   */\n  private _clear(): void {\n    const { localStorage } = window;\n    const prefix = `${this.namespace}:`;\n    let i = localStorage.length;\n\n    while (i) {\n      let key = localStorage.key(--i);\n\n      if (key && key.indexOf(prefix) === 0) {\n        localStorage.removeItem(key);\n      }\n    }\n  }\n\n  /**\n   * Merge data into the state database.\n   */\n  private _merge(contents: ReadonlyJSONObject): void {\n    Object.keys(contents).forEach(key => { this._save(key, contents[key]); });\n  }\n\n  /**\n   * Overwrite the entire database with new contents.\n   */\n  private _overwrite(contents: ReadonlyJSONObject): void {\n    this._clear();\n    this._merge(contents);\n  }\n\n  /**\n   * Save a key and its value in the database.\n   *\n   * #### Notes\n   * Unlike the public `save` method, this method is synchronous.\n   */\n  private _save(id: string, value: ReadonlyJSONValue): void {\n    const key = `${this.namespace}:${id}`;\n    const envelope: Private.Envelope = { v: value };\n    const serialized = JSON.stringify(envelope);\n    const length = serialized.length;\n    const max = this.maxLength;\n\n    if (length > max) {\n      throw new Error(`Data length (${length}) exceeds maximum (${max})`);\n    }\n\n    window.localStorage.setItem(key, serialized);\n  }\n\n  private _changed = new Signal<this, StateDB.Change>(this);\n  private _ready: Promise<void>;\n}\n\n/**\n * A namespace for StateDB statics.\n */\nexport\nnamespace StateDB {\n  /**\n   * A state database change.\n   */\n  export\n  type Change = {\n    /**\n     * The key of the database item that was changed.\n     *\n     * #### Notes\n     * This field is set to `null` for global changes (i.e. `clear`).\n     */\n    id: string | null;\n\n    /**\n     * The type of change.\n     */\n    type: 'clear' | 'remove' | 'save'\n  };\n\n  /**\n   * A data transformation that can be applied to a state database.\n   */\n  export\n  type DataTransform = {\n    /*\n     * The change operation being applied.\n     */\n    type: 'cancel' | 'clear' | 'merge' | 'overwrite',\n\n    /**\n     * The contents of the change operation.\n     */\n    contents: ReadonlyJSONObject | null\n  };\n\n  /**\n   * The instantiation options for a state database.\n   */\n  export\n  interface IOptions {\n    /**\n     * The namespace prefix for all state database entries.\n     */\n    namespace: string;\n\n    /**\n     * An optional promise that resolves with a data transformation that is\n     * applied to the database contents before the database begins resolving\n     * client requests.\n     */\n    transform?: Promise<DataTransform>;\n  }\n}\n\n\n/*\n * A namespace for private module data.\n */\nnamespace Private {\n  /**\n   * An envelope around a JSON value stored in the state database.\n   */\n  export\n  type Envelope = { readonly v: ReadonlyJSONValue };\n}\n"]}