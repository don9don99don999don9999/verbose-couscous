"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@phosphor/coreutils");
var signaling_1 = require("@phosphor/signaling");
/* tslint:disable */
/**
 * The default state database token.
 */
exports.IStateDB = new coreutils_1.Token('@jupyterlab/coreutils:IStateDB');
/**
 * The default concrete implementation of a state database.
 */
var StateDB = /** @class */ (function () {
    /**
     * Create a new state database.
     *
     * @param options - The instantiation options for a state database.
     */
    function StateDB(options) {
        var _this = this;
        /**
         * The maximum allowed length of the data after it has been serialized.
         */
        this.maxLength = 2000;
        this._changed = new signaling_1.Signal(this);
        var namespace = options.namespace, transform = options.transform;
        this.namespace = namespace;
        if (!transform) {
            this._ready = Promise.resolve(undefined);
            return;
        }
        this._ready = transform.then(function (transformation) {
            var contents = transformation.contents, type = transformation.type;
            switch (type) {
                case 'cancel':
                    return;
                case 'clear':
                    _this._clear();
                    return;
                case 'merge':
                    _this._merge(contents || {});
                    return;
                case 'overwrite':
                    _this._overwrite(contents || {});
                    return;
                default:
                    return;
            }
        });
    }
    Object.defineProperty(StateDB.prototype, "changed", {
        get: function () {
            return this._changed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clear the entire database.
     */
    StateDB.prototype.clear = function (silent) {
        var _this = this;
        if (silent === void 0) { silent = false; }
        return this._ready.then(function () {
            _this._clear();
            if (silent) {
                return;
            }
            _this._changed.emit({ id: null, type: 'clear' });
        });
    };
    /**
     * Retrieve a saved bundle from the database.
     *
     * @param id - The identifier used to retrieve a data bundle.
     *
     * @returns A promise that bears a data payload if available.
     *
     * #### Notes
     * The `id` values of stored items in the state database are formatted:
     * `'namespace:identifier'`, which is the same convention that command
     * identifiers in JupyterLab use as well. While this is not a technical
     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
     * using the `fetchNamespace()` method.
     *
     * The promise returned by this method may be rejected if an error occurs in
     * retrieving the data. Non-existence of an `id` will succeed with `null`.
     */
    StateDB.prototype.fetch = function (id) {
        var _this = this;
        return this._ready.then(function () {
            var key = _this.namespace + ":" + id;
            var value = window.localStorage.getItem(key);
            if (value) {
                var envelope = JSON.parse(value);
                return envelope.v;
            }
        });
    };
    /**
     * Retrieve all the saved bundles for a namespace.
     *
     * @param namespace - The namespace to retrieve.
     *
     * @returns A promise that bears a collection data payloads for a namespace.
     *
     * #### Notes
     * Namespaces are entirely conventional entities. The `id` values of stored
     * items in the state database are formatted: `'namespace:identifier'`, which
     * is the same convention that command identifiers in JupyterLab use as well.
     *
     * If there are any errors in retrieving the data, they will be logged to the
     * console in order to optimistically return any extant data without failing.
     * This promise will always succeed.
     */
    StateDB.prototype.fetchNamespace = function (namespace) {
        var _this = this;
        return this._ready.then(function () {
            var localStorage = window.localStorage;
            var prefix = _this.namespace + ":" + namespace + ":";
            var items = [];
            var i = localStorage.length;
            while (i) {
                var key = localStorage.key(--i);
                if (key && key.indexOf(prefix) === 0) {
                    var value = localStorage.getItem(key);
                    try {
                        var envelope = JSON.parse(value);
                        items.push({
                            id: key.replace(_this.namespace + ":", ''),
                            value: envelope ? envelope.v : undefined
                        });
                    }
                    catch (error) {
                        console.warn(error);
                        localStorage.removeItem(key);
                    }
                }
            }
            return items;
        });
    };
    /**
     * Remove a value from the database.
     *
     * @param id - The identifier for the data being removed.
     *
     * @returns A promise that is rejected if remove fails and succeeds otherwise.
     */
    StateDB.prototype.remove = function (id) {
        var _this = this;
        return this._ready.then(function () {
            window.localStorage.removeItem(_this.namespace + ":" + id);
            _this._changed.emit({ id: id, type: 'remove' });
        });
    };
    /**
     * Save a value in the database.
     *
     * @param id - The identifier for the data being saved.
     *
     * @param value - The data being saved.
     *
     * @returns A promise that is rejected if saving fails and succeeds otherwise.
     *
     * #### Notes
     * The `id` values of stored items in the state database are formatted:
     * `'namespace:identifier'`, which is the same convention that command
     * identifiers in JupyterLab use as well. While this is not a technical
     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
     * using the `fetchNamespace()` method.
     */
    StateDB.prototype.save = function (id, value) {
        var _this = this;
        return this._ready.then(function () {
            _this._save(id, value);
            _this._changed.emit({ id: id, type: 'save' });
        });
    };
    /**
     * Return a serialized copy of the state database's entire contents.
     *
     * @returns A promise that bears the database contents as JSON.
     */
    StateDB.prototype.toJSON = function () {
        var _this = this;
        return this._ready.then(function () {
            var localStorage = window.localStorage;
            var prefix = _this.namespace + ":";
            var contents = {};
            var i = localStorage.length;
            while (i) {
                var key = localStorage.key(--i);
                if (key && key.indexOf(prefix) === 0) {
                    var value = localStorage.getItem(key);
                    try {
                        var envelope = JSON.parse(value);
                        if (envelope) {
                            contents[key.replace(prefix, '')] = envelope.v;
                        }
                    }
                    catch (error) {
                        console.warn(error);
                        localStorage.removeItem(key);
                    }
                }
            }
            return contents;
        });
    };
    /**
     * Clear the entire database.
     *
     * #### Notes
     * Unlike the public `clear` method, this method is synchronous.
     */
    StateDB.prototype._clear = function () {
        var localStorage = window.localStorage;
        var prefix = this.namespace + ":";
        var i = localStorage.length;
        while (i) {
            var key = localStorage.key(--i);
            if (key && key.indexOf(prefix) === 0) {
                localStorage.removeItem(key);
            }
        }
    };
    /**
     * Merge data into the state database.
     */
    StateDB.prototype._merge = function (contents) {
        var _this = this;
        Object.keys(contents).forEach(function (key) { _this._save(key, contents[key]); });
    };
    /**
     * Overwrite the entire database with new contents.
     */
    StateDB.prototype._overwrite = function (contents) {
        this._clear();
        this._merge(contents);
    };
    /**
     * Save a key and its value in the database.
     *
     * #### Notes
     * Unlike the public `save` method, this method is synchronous.
     */
    StateDB.prototype._save = function (id, value) {
        var key = this.namespace + ":" + id;
        var envelope = { v: value };
        var serialized = JSON.stringify(envelope);
        var length = serialized.length;
        var max = this.maxLength;
        if (length > max) {
            throw new Error("Data length (" + length + ") exceeds maximum (" + max + ")");
        }
        window.localStorage.setItem(key, serialized);
    };
    return StateDB;
}());
exports.StateDB = StateDB;
