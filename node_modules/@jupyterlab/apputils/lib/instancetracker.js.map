{"version":3,"file":"instancetracker.js","sourceRoot":"","sources":["../../../../apputils/src/instancetracker.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  IStateDB\n} from '@jupyterlab/coreutils';\n\nimport {\n  ArrayExt, each, find\n} from '@phosphor/algorithm';\n\nimport {\n  CommandRegistry\n} from '@phosphor/commands';\n\nimport {\n  ReadonlyJSONObject\n} from '@phosphor/coreutils';\n\nimport {\n  IDisposable\n} from '@phosphor/disposable';\n\nimport {\n  AttachedProperty\n} from '@phosphor/properties';\n\nimport {\n  ISignal, Signal\n} from '@phosphor/signaling';\n\nimport {\n  FocusTracker, Widget\n} from '@phosphor/widgets';\n\n\n/**\n * An object that tracks widget instances.\n */\nexport\ninterface IInstanceTracker<T extends Widget> extends IDisposable {\n  /**\n   * A signal emitted when the current widget changes.\n   *\n   * #### Notes\n   * If the last widget being tracked is disposed, `null` will be emitted.\n   */\n  readonly currentChanged: ISignal<this, T | null>;\n\n  /**\n   * A signal emitted when a widget is added.\n   *\n   * #### Notes\n   * This signal will only fire when a widget is added to the tracker. It will\n   * not fire if a widget is injected into the tracker.\n   */\n  readonly widgetAdded: ISignal<this, T>;\n\n  /**\n   * The current widget is the most recently focused or added widget.\n   *\n   * #### Notes\n   * It is the most recently focused widget, or the most recently added\n   * widget if no widget has taken focus.\n   */\n  readonly currentWidget: T | null;\n\n  /**\n   * The number of widgets held by the tracker.\n   */\n  readonly size: number;\n\n  /**\n   * Iterate through each widget in the tracker.\n   *\n   * @param fn - The function to call on each widget.\n   */\n  forEach(fn: (widget: T) => void): void;\n\n  /**\n   * Check if this tracker has the specified widget.\n   *\n   * @param widget - The widget whose existence is being checked.\n   */\n  has(widget: Widget): boolean;\n\n  /**\n   * Inject a foreign widget into the instance tracker.\n   *\n   * @param widget - The widget to inject into the tracker.\n   *\n   * #### Notes\n   * Any widgets injected into an instance tracker will not have their state\n   * saved by the tracker. The primary use case for widget injection is for a\n   * plugin that offers a sub-class of an extant plugin to have its instances\n   * share the same commands as the parent plugin (since most relevant commands\n   * will use the `currentWidget` of the parent plugin's instance tracker). In\n   * this situation, the sub-class plugin may well have its own instance tracker\n   * for layout and state restoration in addition to injecting its widgets into\n   * the parent plugin's instance tracker.\n   */\n  inject(widget: T): void;\n}\n\n\n/**\n * A class that keeps track of widget instances on an Application shell.\n *\n * #### Notes\n * The API surface area of this concrete implementation is substantially larger\n * than the instance tracker interface it implements. The interface is intended\n * for export by JupyterLab plugins that create widgets and have clients who may\n * wish to keep track of newly created widgets. This class, however, can be used\n * internally by plugins to restore state as well.\n */\nexport\nclass InstanceTracker<T extends Widget> implements IInstanceTracker<T>, IDisposable {\n  /**\n   * Create a new instance tracker.\n   *\n   * @param options - The instantiation options for an instance tracker.\n   */\n  constructor(options: InstanceTracker.IOptions) {\n    this.namespace = options.namespace;\n    this._tracker.currentChanged.connect(this._onCurrentChanged, this);\n  }\n\n  /**\n   * A signal emitted when the current widget changes.\n   */\n  get currentChanged(): ISignal<this, T | null> {\n    return this._currentChanged;\n  }\n\n  /**\n   * A signal emitted when a widget is added.\n   *\n   * #### Notes\n   * This signal will only fire when a widget is added to the tracker. It will\n   * not fire if a widget is injected into the tracker.\n   */\n  get widgetAdded(): ISignal<this, T> {\n    return this._widgetAdded;\n  }\n\n  /**\n   * A signal emitted when a widget is updated.\n   */\n  get widgetUpdated(): ISignal<this, T> {\n    return this._widgetUpdated;\n  }\n\n  /**\n   * A namespace for all tracked widgets, (e.g., `notebook`).\n   */\n  readonly namespace: string;\n\n  /**\n   * The current widget is the most recently focused or added widget.\n   *\n   * #### Notes\n   * It is the most recently focused widget, or the most recently added\n   * widget if no widget has taken focus.\n   */\n  get currentWidget(): T | null {\n    return this._currentWidget;\n  }\n\n  /**\n   * The number of widgets held by the tracker.\n   */\n  get size(): number {\n    return this._tracker.widgets.length;\n  }\n\n  /**\n   * Add a new widget to the tracker.\n   *\n   * @param widget - The widget being added.\n   */\n  add(widget: T): Promise<void> {\n    if (this._tracker.has(widget)) {\n      let warning = `${widget.id} already exists in the tracker.`;\n      console.warn(warning);\n      return Promise.reject(warning);\n    }\n    this._tracker.add(widget);\n    this._widgets.push(widget);\n\n    let injected = Private.injectedProperty.get(widget);\n    let promise: Promise<void> = Promise.resolve(void 0);\n\n    if (injected) {\n      return promise;\n    }\n\n    widget.disposed.connect(this._onWidgetDisposed, this);\n\n    // Handle widget state restoration.\n    if (this._restore) {\n      let { state } = this._restore;\n      let widgetName = this._restore.name(widget);\n\n      if (widgetName) {\n        let name = `${this.namespace}:${widgetName}`;\n        let data = this._restore.args(widget);\n\n        Private.nameProperty.set(widget, name);\n        promise = state.save(name, { data });\n      }\n    }\n\n    // If there is no focused widget, set this as the current widget.\n    if (!this._tracker.currentWidget) {\n      this._currentWidget = widget;\n      this.onCurrentChanged(widget);\n      this._currentChanged.emit(widget);\n    }\n\n    // Emit the widget added signal.\n    this._widgetAdded.emit(widget);\n\n    return promise;\n  }\n\n  /**\n   * Test whether the tracker is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * Dispose of the resources held by the tracker.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n    this._tracker.dispose();\n  }\n\n  /**\n   * Find the first widget in the tracker that satisfies a filter function.\n   *\n   * @param - fn The filter function to call on each widget.\n   *\n   * #### Notes\n   * If no widget is found, the value returned is `undefined`.\n   */\n  find(fn: (widget: T) => boolean): T | undefined {\n    return find(this._tracker.widgets, fn);\n  }\n\n  /**\n   * Iterate through each widget in the tracker.\n   *\n   * @param fn - The function to call on each widget.\n   */\n  forEach(fn: (widget: T) => void): void {\n    each(this._tracker.widgets, widget => { fn(widget); });\n  }\n\n  /**\n   * Inject a foreign widget into the instance tracker.\n   *\n   * @param widget - The widget to inject into the tracker.\n   *\n   * #### Notes\n   * Any widgets injected into an instance tracker will not have their state\n   * saved by the tracker. The primary use case for widget injection is for a\n   * plugin that offers a sub-class of an extant plugin to have its instances\n   * share the same commands as the parent plugin (since most relevant commands\n   * will use the `currentWidget` of the parent plugin's instance tracker). In\n   * this situation, the sub-class plugin may well have its own instance tracker\n   * for layout and state restoration in addition to injecting its widgets into\n   * the parent plugin's instance tracker.\n   */\n  inject(widget: T): void {\n    Private.injectedProperty.set(widget, true);\n    this.add(widget);\n  }\n\n  /**\n   * Check if this tracker has the specified widget.\n   *\n   * @param widget - The widget whose existence is being checked.\n   */\n  has(widget: Widget): boolean {\n    return this._tracker.has(widget as any);\n  }\n\n  /**\n   * Restore the widgets in this tracker's namespace.\n   *\n   * @param options - The configuration options that describe restoration.\n   *\n   * @returns A promise that resolves when restoration has completed.\n   *\n   * #### Notes\n   * This function should almost never be invoked by client code. Its primary\n   * use case is to be invoked by a layout restorer plugin that handles\n   * multiple instance trackers and, when ready, asks them each to restore their\n   * respective widgets.\n   */\n  restore(options: InstanceTracker.IRestoreOptions<T>): Promise<any> {\n    const { command, registry, state, when } = options;\n    const namespace = this.namespace;\n    const promises = when ? [state.fetchNamespace(namespace)].concat(when)\n      : [state.fetchNamespace(namespace)];\n\n    this._restore = options;\n\n    return Promise.all(promises).then(([saved]) => {\n      return Promise.all(saved.map(item => {\n        const { id, value } = item;\n        const args = value && (value as any).data;\n        if (args === undefined) {\n          return state.remove(item.id);\n        }\n\n        // Execute the command and if it fails, delete the state restore data.\n        return registry.execute(command, args).catch(() => state.remove(id));\n      }));\n    });\n  }\n\n  /**\n   * Save the restore data for a given widget.\n   *\n   * @param widget - The widget being saved.\n   */\n  save(widget: T): void {\n    const injected = Private.injectedProperty.get(widget);\n\n    if (!this._restore || !this.has(widget) || injected) {\n      return;\n    }\n\n    const { state } = this._restore;\n    const widgetName = this._restore.name(widget);\n    const oldName = Private.nameProperty.get(widget);\n    const newName = widgetName ? `${this.namespace}:${widgetName}` : '';\n\n    if (oldName && oldName !== newName) {\n      state.remove(oldName);\n    }\n\n    // Set the name property irrespective of whether the new name is null.\n    Private.nameProperty.set(widget, newName);\n\n    if (newName) {\n      const data = this._restore.args(widget);\n      state.save(newName, { data });\n    }\n\n    if (oldName !== newName) {\n      this._widgetUpdated.emit(widget);\n    }\n  }\n\n  /**\n   * Handle the current change event.\n   *\n   * #### Notes\n   * The default implementation is a no-op.\n   */\n  protected onCurrentChanged(value: T | null): void { /* no-op */ }\n\n  /**\n   * Handle the current change signal from the internal focus tracker.\n   */\n  private _onCurrentChanged(sender: any, args: FocusTracker.IChangedArgs<T>): void {\n    // Bail if the active widget did not change.\n    if (args.newValue === this._currentWidget) {\n      return;\n    }\n\n    this._currentWidget = args.newValue;\n    this.onCurrentChanged(args.newValue);\n    this._currentChanged.emit(args.newValue);\n  }\n\n  /**\n   * Clean up after disposed widgets.\n   */\n  private _onWidgetDisposed(widget: T): void {\n    const injected = Private.injectedProperty.get(widget);\n\n    if (injected) {\n      return;\n    }\n\n    // Handle widget removal.\n    ArrayExt.removeFirstOf(this._widgets, widget);\n\n    // Handle the current widget being disposed.\n    if (widget === this._currentWidget) {\n      this._currentWidget = (\n        this._tracker.currentWidget ||\n        this._widgets[this._widgets.length - 1] ||\n        null\n      );\n      this._currentChanged.emit(this._currentWidget);\n      this.onCurrentChanged(this._currentWidget);\n    }\n\n    // If there is no restore data, return.\n    if (!this._restore) {\n      return;\n    }\n\n    const { state } = this._restore;\n    const name = Private.nameProperty.get(widget);\n\n    if (name) {\n      state.remove(name);\n    }\n  }\n\n  private _restore: InstanceTracker.IRestoreOptions<T> | null = null;\n  private _tracker = new FocusTracker<T>();\n  private _currentChanged = new Signal<this, T | null>(this);\n  private _widgetAdded = new Signal<this, T>(this);\n  private _widgetUpdated = new Signal<this, T>(this);\n  private _widgets: T[] = [];\n  private _currentWidget: T | null = null;\n  private _isDisposed = false;\n}\n\n\n\n/**\n * A namespace for `InstanceTracker` statics.\n */\nexport\nnamespace InstanceTracker {\n  /**\n   * The instantiation options for an instance tracker.\n   */\n  export\n  interface IOptions {\n    /**\n     * A namespace for all tracked widgets, (e.g., `notebook`).\n     */\n    namespace: string;\n  }\n\n  /**\n   * The state restoration configuration options.\n   */\n  export\n  interface IRestoreOptions<T extends Widget> {\n    /**\n     * The command to execute when restoring instances.\n     */\n    command: string;\n\n    /**\n     * A function that returns the args needed to restore an instance.\n     */\n    args: (widget: T) => ReadonlyJSONObject;\n\n    /**\n     * A function that returns a unique persistent name for this instance.\n     */\n    name: (widget: T) => string;\n\n    /**\n     * The command registry which holds the restore command.\n     */\n    registry: CommandRegistry;\n\n    /**\n     * The state database instance.\n     */\n    state: IStateDB;\n\n    /**\n     * The point after which it is safe to restore state.\n     *\n     * #### Notes\n     * By definition, this promise or promises will happen after the application\n     * has `started`.\n     */\n    when?: Promise<any> | Array<Promise<any>>;\n  }\n}\n\n\n/*\n * A namespace for private data.\n */\nnamespace Private {\n  /**\n   * An attached property to indicate whether a widget has been injected.\n   */\n  export\n  const injectedProperty = new AttachedProperty<Widget, boolean>({\n    name: 'injected',\n    create: () => false\n  });\n\n  /**\n   * An attached property for a widget's ID in the state database.\n   */\n  export\n  const nameProperty = new AttachedProperty<Widget, string>({\n    name: 'name',\n    create: () => ''\n  });\n}\n"]}